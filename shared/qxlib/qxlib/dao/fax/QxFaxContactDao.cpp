#include "QxFaxContactDao.hpp"

template<> const bool QxBaseDao<qx::FaxContact>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::FaxContact>::tableName = "qx_fax_contact";
template<> const std::vector<std::string> QxBaseDao<qx::FaxContact>::columnNames = {
    "id",
    "uuid",
    "fax_number",
    "voice_number",
    "organization",
    "contact_name",
    "is_created_by_user",
    "group_qliq_id",
};

template<>
QxBaseDao<qx::FaxContact>::variant QxBaseDao<qx::FaxContact>::primaryKey(const qx::FaxContact& u)
{
    return std::to_string(u.databaseId);
}

template<>
void QxBaseDao<qx::FaxContact>::setPrimaryKey(qx::FaxContact *obj, const QxBaseDao<qx::FaxContact>::variant& key)
{
    obj->databaseId = std::stoi(key);
}

template<>
void QxBaseDao<qx::FaxContact>::bind(SQLite::Statement& q, const qx::FaxContact& obj, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", obj.databaseId);
    }
    q.bind(":uuid", obj.uuid);
    q.bind(":fax_number", obj.faxNumber);
    q.bind(":voice_number", obj.voiceNumber);
    q.bind(":organization", obj.organization);
    q.bind(":contact_name", obj.contactName);
    q.bind(":is_created_by_user", obj.isCreatedByUser ? 1 : 0);
    q.bind(":group_qliq_id", obj.groupQliqId);
}

template<>
void QxBaseDao<qx::FaxContact>::fillFromQuery(qx::FaxContact *obj, SQLite::Statement& record)
{
    obj->databaseId = record.getColumn("id").getInt();
    obj->uuid = record.getColumn("uuid").getText();
    obj->faxNumber = record.getColumn("fax_number").getText();
    obj->voiceNumber = record.getColumn("voice_number").getText();
    obj->organization = record.getColumn("organization").getText();
    obj->contactName = record.getColumn("contact_name").getText();
    obj->isCreatedByUser = record.getColumn("is_created_by_user").getInt() == 1;
    obj->groupQliqId = record.getColumn("group_qliq_id").getText();
}

template<>
qx::FaxContact QxBaseDao<qx::FaxContact>::fromQuery(SQLite::Statement &record)
{
    qx::FaxContact obj;
    fillFromQuery(&obj, record);
    return obj;
}

int qx::FaxContactDao::deleteNotIn(const std::vector<qx::FaxContact> &contacts, SQLite::Database& db)
{
    bool ret = false;
    std::string where;
    if (!contacts.empty()) {
        where = " WHERE " + columnNames[IdColumn] + " NOT IN (";
        int i = 0;
        for (const auto& c: contacts) {
            if (i++ > 0) {
                where += ", ";
            }
            where += std::to_string(c.databaseId);
        }
        where += ")";
    }
    const std::string sql = "DELETE FROM " + tableName + where;
    try {
        SQLite::Statement q(db, sql);
        ret = q.exec();
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}

std::vector<qx::FaxContact> qx::FaxContactDao::search(const std::string &filter, int limit, int skip, SQLite::Database &db)
{
    std::vector<qx::FaxContact> ret;
    std::string sql = "SELECT * FROM " + tableName;
    if (!filter.empty()) {
        sql += " WHERE "
        "contact_name LIKE :contact_name || '%' OR "
        "organization LIKE :organization || '%' OR "
        "fax_number   LIKE :fax_number   || '%' OR "
        "voice_number LIKE :voice_number || '%'";
    }

    try {
        if (limit > 0) {
            sql += " LIMIT " + std::to_string(limit);
        }
        if (skip > 0) {
            sql += " OFFSET " + std::to_string(skip);
        }

        SQLite::Statement q(db, sql);
        if (!filter.empty()) {
            q.bind(":contact_name", filter);
            q.bind(":organization", filter);
            q.bind(":fax_number", filter);
            q.bind(":voice_number", filter);
        }

        while (q.executeStep()) {
            ret.push_back(fromQuery(q));
        }
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}
