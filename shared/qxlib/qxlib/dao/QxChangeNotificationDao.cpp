#include "QxChangeNotificationDao.hpp"

template<> const bool QxBaseDao<qx::ChangeNotification>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::ChangeNotification>::tableName = "qx_change_notification";
template<> const std::vector<std::string> QxBaseDao<qx::ChangeNotification>::columnNames = {
    "id", "subject", "qliq_id", "json", "has_payload", "timestamp", "errors"
};

template<>
QxBaseDao<qx::ChangeNotification>::variant QxBaseDao<qx::ChangeNotification>::primaryKey(const qx::ChangeNotification& u)
{
    return std::to_string(u.databaseId);
}

template<>
void QxBaseDao<qx::ChangeNotification>::setPrimaryKey(qx::ChangeNotification *obj, const QxBaseDao<qx::ChangeNotification>::variant& key)
{
    obj->databaseId = std::stoi(key);
}

template<>
void QxBaseDao<qx::ChangeNotification>::bind(SQLite::Statement& q, const qx::ChangeNotification& obj, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", obj.databaseId);
    }
    q.bind(":subject", obj.subject);
    q.bind(":qliq_id", obj.qliqId);
    q.bind(":json", obj.json);
    q.bind(":has_payload", obj.hasPayload ? 1 : 0);
    q.bind(":timestamp", static_cast<int>(obj.timestamp));
    q.bind(":errors", obj.errors);
}

template<>
void QxBaseDao<qx::ChangeNotification>::fillFromQuery(qx::ChangeNotification *obj, SQLite::Statement& record)
{
    obj->databaseId = record.getColumn("id").getInt();
    obj->subject = record.getColumn("subject").getText();
    obj->qliqId = record.getColumn("qliq_id").getText();
    obj->json = record.getColumn("json").getText();
    obj->hasPayload = record.getColumn("has_payload").getInt() == 1;
    obj->timestamp = record.getColumn("timestamp").getInt();
    obj->errors = record.getColumn("errors").getText();
}

template<>
qx::ChangeNotification QxBaseDao<qx::ChangeNotification>::fromQuery(SQLite::Statement &record)
{
    qx::ChangeNotification obj;
    fillFromQuery(&obj, record);
    return obj;
}

namespace qx {

ChangeNotification::ChangeNotification() :
    databaseId(0), hasPayload(false), timestamp(0)
{
}

bool ChangeNotification::isEmpty() const
{
    return json.empty();
}

void ChangeNotification::clear()
{
    databaseId = 0;
    subject.clear();
    qliqId.clear();
    json.clear();
    hasPayload = false;
    timestamp = 0;
    errors.clear();
}

//int ChangeNotificationDao::insert(const std::string &subject,
//                                  const std::string &qliqId,
//                                  const std::string &json, SQLite::Database &db)
//{
//    dao::Query q;
//    q.append(SubjectColumn, subject);
//    q.and_(QliqIdColumn, qliqId);
//    int id = exists(q, db);
//    if (id != 0) {
//        ChangeNotification cn;
//        cn.databaseId = id;
//        QXLOG_INFO("Updateding CN(%d, %s, %s) with new json", id, subject.c_str(), qliqId.c_str());
//        updateColumn(JsonColumn, json, cn, db);
//    } else {
//        ChangeNotification cn;
//        cn.subject = subject;
//        cn.qliqId = qliqId;
//        cn.json = json;
//        cn.timestamp = std::time(nullptr);
//        cn.attemptCount = 0;
//        cn.lastErrorCode = 0;
//        id = QxBaseDao<ChangeNotification>::insert(cn, db);
//        QXLOG_INFO("Inserted CN(%d, %s, %s)", id, subject.c_str(), qliqId.c_str());
//    }
//    return id;
//}

int ChangeNotificationDao::insert(ChangeNotification *cn, SQLite::Database& db)
{
    dao::Query q;
    q.append(SubjectColumn, cn->subject);
    q.and_(QliqIdColumn, cn->qliqId);
    int id = exists(q, db);
    if (id != 0) {
        cn->databaseId = id;
        QXLOG_INFO("Updating CN(%d, %s, %s) with new json", id, cn->subject.c_str(), cn->qliqId.c_str());
        updateColumn(JsonColumn, cn->json, *cn, db);
    } else {
        cn->timestamp = std::time(nullptr);
        id = QxBaseDao<ChangeNotification>::insert(cn, db);
        QXLOG_INFO("Inserted CN(%d, %s, %s)", id, cn->subject.c_str(), cn->qliqId.c_str());
    }
    return id;
}

void ChangeNotificationDao::remove(int id, SQLite::Database &db)
{
    QXLOG_INFO("Removing CN(%d)", id);
    delete_(IdColumn, std::to_string(id), db);
}

void ChangeNotificationDao::updateErrorCode(int id, int errorCode, SQLite::Database &db)
{
    QXLOG_INFO("Updating error code CN(%d, %d)", id, errorCode);
    std::string sql = "UPDATE " + tableName + " SET errors = coalesce(errors || ', ', '') || " + std::to_string(errorCode)
        + " WHERE id = " + std::to_string(id);
    try {
        db.exec(sql);
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
}

} // namespace qx
