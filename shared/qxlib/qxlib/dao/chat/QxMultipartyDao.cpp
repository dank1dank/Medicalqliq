#include "qxlib/dao/chat/QxMultipartyDao.hpp"
#include "qxlib/util/StringUtils.hpp"

template<> const bool QxBaseDao<qx::Multiparty>::autogeneratedPrimaryKey = false;
template<> const std::string QxBaseDao<qx::Multiparty>::tableName = "multiparty";
template<> const std::vector<std::string> QxBaseDao<qx::Multiparty>::columnNames = {
    "qliq_id", "name", "participants" //, "roles"
};

template<>
QxBaseDao<qx::Multiparty>::variant QxBaseDao<qx::Multiparty>::primaryKey(const qx::Multiparty& u)
{
    return u.qliqId;
}

template<>
void QxBaseDao<qx::Multiparty>::setPrimaryKey(qx::Multiparty *obj, const QxBaseDao<qx::Multiparty>::variant& key)
{
    obj->qliqId = key;
}

template<>
void QxBaseDao<qx::Multiparty>::bind(SQLite::Statement& q, const qx::Multiparty& mp, bool skipPrimaryKey)
{
    std::string participantsString;
    std::string rolesString;

    for (const auto& p: mp.participants) {
        if (p.isEmpty()) {
            continue;
        }

        if (!participantsString.empty()) {
            participantsString += ";";
        }
        if (!rolesString.empty()) {
            rolesString += ";";
        }

        participantsString += p.qliqId;
        rolesString += p.qliqId;

        if (!p.role.empty()) {
            rolesString += "~";
            rolesString += p.role;
        }
    }

    if (!skipPrimaryKey) {
        q.bind(":qliq_id", mp.qliqId);
    }
    q.bind(":name", mp.name);
//    q.bind(":participants", participantsString);
//    q.bind(":roles", rolesString);
    q.bind(":participants", rolesString);
}

template<>
void QxBaseDao<qx::Multiparty>::fillFromQuery(qx::Multiparty *mp, SQLite::Statement& record)
{
    mp->qliqId = record.getColumn("qliq_id").getText();
    mp->name = record.getColumn("name").getText();
    std::string participantsString = record.getColumn("participants").getText();
    std::string rolesString;// = record.getColumn("roles").getText();

    if (rolesString.empty()) {
        rolesString = participantsString;
    }

    const auto& participantsVec = StringUtils::split(rolesString, ';');
    //const auto& rolesVec = StringUtils::split(rolesString, ';');

    for (const auto& entry: participantsVec) {
        const auto& qliqIdAndRole = StringUtils::split(entry, '~');

        qx::Multiparty::Participant p;
        p.qliqId = qliqIdAndRole[0];
        if (qliqIdAndRole.size() > 1) {
            p.role = qliqIdAndRole[1];
        }
        mp->participants.insert(p);
    }
}

template<>
qx::Multiparty QxBaseDao<qx::Multiparty>::fromQuery(SQLite::Statement &record)
{
    qx::Multiparty obj;
    fillFromQuery(&obj, record);
    return obj;
}

qx::Multiparty qx::MultipartyDao::selectOneByQliqId(const std::string &qliqId)
{
    return selectOneBy(QliqIdColumn, qliqId);
}
