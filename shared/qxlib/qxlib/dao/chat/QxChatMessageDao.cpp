#include "QxChatMessageDao.hpp"
#include "qxlib/model/QxSession.hpp"
#include "qxlib/dao/QxQliqUserDao.hpp"
#include <cstdlib>

////////////////////////////////////////////////////////////////////////////////
/// Conversation
///
template<> const bool QxBaseDao<qx::Conversation>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::Conversation>::tableName = "conversation";
template<> const std::vector<std::string> QxBaseDao<qx::Conversation>::columnNames = {
    "id", "conversation_uuid", "subject"
};

template<>
QxBaseDao<qx::Conversation>::variant QxBaseDao<qx::Conversation>::primaryKey(const qx::Conversation& u)
{
    return std::to_string(u.id);
}

template<>
void QxBaseDao<qx::Conversation>::setPrimaryKey(qx::Conversation *obj, const QxBaseDao<qx::Conversation>::variant& key)
{
    obj->id = std::atoi(key.c_str());
}

template<>
void QxBaseDao<qx::Conversation>::bind(SQLite::Statement& q, const qx::Conversation& msg, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", msg.id);
    }
    q.bind(":conversation_uuid", msg.uuid);
    q.bind(":subject", msg.subject);
}

template<>
void QxBaseDao<qx::Conversation>::fillFromQuery(qx::Conversation *obj, SQLite::Statement& record)
{
    obj->id = record.getColumn("id").getInt();
    obj->uuid = record.getColumn("conversation_uuid").getText();
    obj->subject = record.getColumn("subject").getText();
}

template<>
qx::Conversation QxBaseDao<qx::Conversation>::fromQuery(SQLite::Statement &record)
{
    qx::Conversation obj;
    fillFromQuery(&obj, record);
    return obj;
}

////////////////////////////////////////////////////////////////////////////////
/// ChatMessage
///
template<> const bool QxBaseDao<qx::ChatMessage>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::ChatMessage>::tableName = "message";
template<> const std::vector<std::string> QxBaseDao<qx::ChatMessage>::columnNames = {
    "id", "conversation_id", "uuid", "timestamp",
#if defined(QXL_DEVICE_PC) && !defined(TEST_MOBILE_DB)
    "from_user_id", "to_user_id",
#else
    "from_qliq_id", "to_qliq_id",
#endif
    "message", "ack_required", "delivery_status", "status_text", "type",
    "has_attachment", "deleted", "recall_status"
};

template<>
QxBaseDao<qx::ChatMessage>::variant QxBaseDao<qx::ChatMessage>::primaryKey(const qx::ChatMessage& u)
{
    return std::to_string(u.id);
}

template<>
void QxBaseDao<qx::ChatMessage>::setPrimaryKey(qx::ChatMessage *obj, const QxBaseDao<qx::ChatMessage>::variant& key)
{
    obj->id = std::atoi(key.c_str());
}

template<>
void QxBaseDao<qx::ChatMessage>::bind(SQLite::Statement& q, const qx::ChatMessage& msg, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", msg.id);
    }
    q.bind(":conversation_id", msg.conversationId);
    q.bind(":uuid", msg.uuid);
    q.bind(":timestamp", static_cast<int>(msg.timestamp));
#if defined(QXL_DEVICE_PC) && !defined(TEST_MOBILE_DB)
    q.bind(":from_user_id", msg.fromQliqId);
    q.bind(":to_user_id", msg.toQliqId);
#else
    q.bind(":from_qliq_id", msg.fromQliqId);
    q.bind(":to_qliq_id", msg.toQliqId);
#endif
    q.bind(":message", msg.text);
    q.bind(":ack_required", msg.isAckRequired);
    q.bind(":delivery_status", msg.deliveryStatus);
    q.bind(":status_text", msg.statusText);
    q.bind(":type", static_cast<int>(msg.type));
    q.bind(":has_attachment", msg.hasAttachment);
}

template<>
void QxBaseDao<qx::ChatMessage>::fillFromQuery(qx::ChatMessage *obj, SQLite::Statement& record)
{
    obj->id = record.getColumn("id").getInt();
    obj->conversationId = record.getColumn("conversation_id").getInt();
    obj->uuid = record.getColumn("uuid").getText();
    obj->timestamp = record.getColumn("timestamp").getInt();
#if defined(QXL_DEVICE_PC) && !defined(TEST_MOBILE_DB)
    obj->fromQliqId = record.getColumn("from_user_id").getText();
    obj->toQliqId = record.getColumn("to_user_id").getText();
#else
    obj->fromQliqId = record.getColumn("from_qliq_id").getText();
    obj->toQliqId = record.getColumn("to_qliq_id").getText();
#endif
    obj->text = record.getColumn("message").getText();
    obj->isAckRequired = record.getColumn("ack_required").getInt() == 1;
    obj->deliveryStatus = record.getColumn("delivery_status").getInt();
    obj->statusText = record.getColumn("status_text").getText();
    obj->type = static_cast<qx::ChatMessage::Type>(record.getColumn("type").getInt());
    obj->hasAttachment = record.getColumn("has_attachment").getInt() == 1;
}

template<>
qx::ChatMessage QxBaseDao<qx::ChatMessage>::fromQuery(SQLite::Statement &record)
{
    qx::ChatMessage obj;
    fillFromQuery(&obj, record);
    return obj;
}

namespace {

int unreadMessageCount(bool isCareChannel)
{
    int ret = 0;
    std::string sql = "SELECT COUNT(read_at) FROM message WHERE NOT read_at AND deleted = 0 AND conversation_id XXX IN (SELECT conversation.id FROM conversation JOIN fhir_encounter ON conversation.conversation_uuid = fhir_encounter.uuid)";
    auto it = sql.find("XXX");
    sql.replace(it, 3, isCareChannel ? "   " : "NOT");

    try {
        SQLite::Database& db = QxDatabase::database();
        SQLite::Statement q(db, sql);
        if (q.executeStep()) {
            ret = q.getColumn(0).getInt();
        }
    } QX_DAO_CATCH_BLOCK
    return ret;
}

} // namespace

namespace qx {

int ChatMessageDao::unreadConversationMessageCount()
{
    return unreadMessageCount(false);
}

int ChatMessageDao::unreadCareChannelMessageCount()
{
    return unreadMessageCount(true);
}

std::vector<ChatMessageDao::Result> ChatMessageDao::fullTextSearch(const std::string &pattern, int limit, int skip, SQLite::Database &db)
{
    std::vector<Result> ret;
    std::string sql = "SELECT message.id, message.conversation_id, message.from_user_id, message.timestamp, "
        "conversation.subject, snippet(chat_message_fts, 0, '<b>', '</b>', '...', 10) "
        "FROM chat_message_fts "
        "JOIN message ON (message.id = chat_message_fts.rowid) "
        "JOIN conversation ON (conversation.id = message.conversation_id) "
        "WHERE chat_message_fts MATCH :pattern";

    try {
        if (limit > 0) {
            sql += " LIMIT " + std::to_string(limit);
        }
        if (skip > 0) {
            sql += " OFFSET " + std::to_string(skip);
        }

        SQLite::Statement q(db, sql);
        q.bind(":pattern", pattern);
        while (q.executeStep()) {
            Result r;
            r.messageId = q.getColumn(0).getInt();
            r.conversationId = q.getColumn(1).getInt();
            r.fromQliqId = q.getColumn(2).getText();
            r.timestamp = q.getColumn(3).getInt();
            r.subject = q.getColumn(4).getText();
            r.snippet = q.getColumn(5).getText();
            ret.push_back(r);
        }
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}

#if defined(QXL_DEVICE_PC) && !defined(QT_NO_DEBUG)

void ChatMessageDao::test()
{
#ifdef TEST_IPHONE_DB
    SQLite::Database db("c:\\temp\\assembla\\iphone\\upload wrong status\\iphone\\847222992-plain.sqlite");
    ChatMessage msg = ChatMessageDao::selectOneBy(ChatMessageDao::IdColumn, "1", 0, db);
    if (msg.id > 0) {
        std::vector<MessageStatusLog::Entry> statusLog = MessageStatusLogEntryDao::selectBy(MessageStatusLogEntryDao::MessageIdColumn, std::to_string(msg.id), 0, 0, db);
        if (!statusLog.empty()) {

        }

        Conversation conv = ConversationDao::selectOneBy(ConversationDao::IdColumn, std::to_string(msg.conversationId));
        if (!conv.isEmpty()) {

        }
    }
#else
    ChatMessage msg = ChatMessageDao::selectOneBy(ChatMessageDao::UuidColumn, "0d2380f9-dfd2-4018-b5f9-fe1e3d1baaf8");
    if (msg.id > 0) {
        std::vector<MessageStatusLog::Entry> statusLog = MessageStatusLogEntryDao::selectBy(MessageStatusLogEntryDao::MessageIdColumn, std::to_string(msg.id));
        if (!statusLog.empty()) {

        }

        ChatMessageAttachment attachment = ChatMessageAttachmentDao::selectOneBy(ChatMessageAttachmentDao::MessageUuidColumn, msg.uuid);
        if (attachment.id > 0) {
            std::string test = attachment.fileName;
            test += ".test";
        }
    }
#endif
}

#endif // defined(QXL_DEVICE_PC) && !defined(QT_NO_DEBUG)

} // namespace qx

template<> const bool QxBaseDao<qx::ChatMessageAttachment>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::ChatMessageAttachment>::tableName = "message_attachment";
template<> const std::vector<std::string> QxBaseDao<qx::ChatMessageAttachment>::columnNames = {
    "id", "uuid", "url",
#if defined(QXL_DEVICE_PC) && !defined(TEST_MOBILE_DB)
    "mime", "file_name",
#else
    "mediafiles.file_mime_type", "mediafiles.file_name",
#endif
     "thumbnail",
#ifdef QXL_DEVICE_PC
    "media_file_status"
#endif
};

#if !defined(QXL_DEVICE_PC) || defined(TEST_MOBILE_DB)
#define OPTIONAL_JOIN_FOR_SELECT " JOIN mediafiles ON (mediafiles.id = message_attachment.mediafile_id)"
#endif // !QXL_DEVICE_PC

template<>
QxBaseDao<qx::ChatMessageAttachment>::variant QxBaseDao<qx::ChatMessageAttachment>::primaryKey(const qx::ChatMessageAttachment& u)
{
    return std::to_string(u.id);
}

template<>
void QxBaseDao<qx::ChatMessageAttachment>::setPrimaryKey(qx::ChatMessageAttachment *obj, const QxBaseDao<qx::ChatMessageAttachment>::variant& key)
{
    obj->id = std::atoi(key.c_str());
}

template<>
void QxBaseDao<qx::ChatMessageAttachment>::bind(SQLite::Statement& q, const qx::ChatMessageAttachment& msg, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", msg.id);
    }
    q.bind(":uuid", msg.messageUuid);
    q.bind(":url", msg.url);
#if defined(QXL_DEVICE_PC) && !defined(TEST_MOBILE_DB)
    q.bind(":mime", msg.mime);
    q.bind(":file_name", msg.fileName);
#else
    q.bind(":file_mime_type", msg.mime);
    q.bind(":mime", msg.mime);
#endif
    q.bind(":thumbnail", msg.thumbnail);
#ifdef QXL_DEVICE_PC
    q.bind(":media_file_status", static_cast<int>(msg.mediaFileStatus));
#endif
}

template<>
void QxBaseDao<qx::ChatMessageAttachment>::fillFromQuery(qx::ChatMessageAttachment *obj, SQLite::Statement& record)
{
    obj->id = record.getColumn("id").getInt();
    obj->messageUuid = record.getColumn("uuid").getText();
    obj->url = record.getColumn("url").getText();
#if defined(QXL_DEVICE_PC) && !defined(TEST_MOBILE_DB)
    obj->mime = record.getColumn("mime").getText();
    obj->fileName = record.getColumn("file_name").getText();
#else
    obj->mime = record.getColumn("file_mime_type").getText();
    obj->fileName = record.getColumn("file_name").getText();
#endif
    obj->thumbnail = record.getColumn("thumbnail").getText();
#ifdef QXL_DEVICE_PC
    obj->mediaFileStatus = static_cast<qx::ChatMessageAttachment::MediaFileStatus>(record.getColumn("media_file_status").getInt());
#endif
}

template<>
qx::ChatMessageAttachment QxBaseDao<qx::ChatMessageAttachment>::fromQuery(SQLite::Statement &record)
{
    qx::ChatMessageAttachment obj;
    fillFromQuery(&obj, record);
    return obj;
}

#if !defined(QXL_DEVICE_PC) || defined(TEST_MOBILE_DB)

qx::ChatMessageAttachment qx::ChatMessageAttachmentDao::selectOneBy(ChatMessageAttachmentDao::Column column, const QxBaseDao::variant &value, int skip, SQLite::Database &db)
{
    ChatMessageAttachment ret;
    std::string sql = "SELECT * FROM " + tableName + " " + OPTIONAL_JOIN_FOR_SELECT + " WHERE message_attachment." + columnNames[column] + " = :qvalue LIMIT 1 OFFSET " + std::to_string(skip);
    try {
        SQLite::Statement q(db, sql);
        q.bind(":qvalue", value);
        if (q.executeStep()) {
            ret = fromQuery(q);
        }
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}

#endif // !defined(QXL_DEVICE_PC) || defined(TEST_MOBILE_DB)

#ifdef QXL_DEVICE_PC

bool qx::ChatMessageAttachmentDao::setMediaFileStatusDeleted(const std::string &messageUuid, SQLite::Database& db)
{
    bool ret = false;
    std::string sql = "UPDATE " + tableName + " SET " + columnNames[MediaFileStatusColumn] +
        " = " + std::to_string(static_cast<int>(qx::ChatMessageAttachment::MediaFileStatus::Deleted)) + " WHERE " +
        columnNames[MessageUuidColumn] + " = :uuid";
    try {
        SQLite::Statement q(db, sql);
        q.bind(":uuid", messageUuid);
        ret = q.exec();
    } QX_DAO_CATCH_BLOCK;
    return ret;
}

#endif // QXL_DEVICE_PC

////////////////////////////////////////////////////////////////////////////////
/// MessageStatusLog
///
template<> const bool QxBaseDao<qx::MessageStatusLog::Entry>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::MessageStatusLog::Entry>::tableName = "message_status_log";
template<> const std::vector<std::string> QxBaseDao<qx::MessageStatusLog::Entry>::columnNames = {
    "message_id", "timestamp", "status", "qliq_id", "status_text"
};

template<>
QxBaseDao<qx::MessageStatusLog::Entry>::variant QxBaseDao<qx::MessageStatusLog::Entry>::primaryKey(const qx::MessageStatusLog::Entry& u)
{
    return std::to_string(u.id);
}

template<>
void QxBaseDao<qx::MessageStatusLog::Entry>::setPrimaryKey(qx::MessageStatusLog::Entry *obj, const QxBaseDao<qx::MessageStatusLog::Entry>::variant& key)
{
    obj->id = std::atoi(key.c_str());
}

template<>
void QxBaseDao<qx::MessageStatusLog::Entry>::bind(SQLite::Statement& q, const qx::MessageStatusLog::Entry& msg, bool skipPrimaryKey)
{
    q.bind(":message_id", msg.messageId);
    q.bind(":timestamp", static_cast<int>(msg.timestamp));
    q.bind(":status", msg.status);
    q.bind(":qliq_id", msg.qliqId);
    q.bind(":status_text", msg.statusTextFromServer);
}

template<>
void QxBaseDao<qx::MessageStatusLog::Entry>::fillFromQuery(qx::MessageStatusLog::Entry *obj, SQLite::Statement& record)
{
    obj->messageId = record.getColumn("message_id").getInt();
    obj->timestamp = record.getColumn("timestamp").getInt();
    obj->status = record.getColumn("status").getInt();
    obj->qliqId = record.getColumn("qliq_id").getText();
    obj->statusTextFromServer = record.getColumn("status_text").getText();
}

template<>
qx::MessageStatusLog::Entry QxBaseDao<qx::MessageStatusLog::Entry>::fromQuery(SQLite::Statement &record)
{
    qx::MessageStatusLog::Entry obj;
    fillFromQuery(&obj, record);
    return obj;
}

