#include "QxMediaFileDao.hpp"

template<> const bool QxBaseDao<qx::MediaFile>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::MediaFile>::tableName = "qx_media_file";
template<> const std::vector<std::string> QxBaseDao<qx::MediaFile>::columnNames = {
    "id", "mime", "key", "file_name", "size", "checksum", "thumbnail", "url",
    "encrypted_file_path", "decrypted_file_path", /*"original_file_path",*/ "status", "timestamp",
    "encryption_method", "encrypted_key", "public_key_md5",
    "extra_key_encrypted_key", "extra_key_public_key_md5", "extra_key_qliq_id"
};

template<>
QxBaseDao<qx::MediaFile>::variant QxBaseDao<qx::MediaFile>::primaryKey(const qx::MediaFile& u)
{
    return std::to_string(u.databaseId);
}

template<>
void QxBaseDao<qx::MediaFile>::setPrimaryKey(qx::MediaFile *obj, const QxBaseDao<qx::MediaFile>::variant& key)
{
    obj->databaseId = std::stoi(key);
}

template<>
void QxBaseDao<qx::MediaFile>::bind(SQLite::Statement& q, const qx::MediaFile& obj, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", obj.databaseId);
    }
    q.bind(":mime", obj.mime);
    q.bind(":key", obj.key);
    q.bind(":file_name", obj.fileName);
    q.bind(":size", static_cast<sqlite_int64>(obj.size));
    q.bind(":checksum", obj.checksum);
    q.bind(":thumbnail", obj.thumbnail);
    q.bind(":url", obj.url);
    q.bind(":encrypted_file_path", obj.encryptedFilePath);
    q.bind(":decrypted_file_path", obj.decryptedFilePath);
    q.bind(":status", obj.status);
    q.bind(":timestamp", static_cast<sqlite3_int64>(obj.timestamp));
    q.bind(":encryption_method", obj.encryptionMethod);
    q.bind(":encrypted_key", obj.encryptedKey);
    q.bind(":public_key_md5", obj.publicKeyMd5);

    std::string extraKeyEncryptedKey, extraKeyPublicKeyMd5, extraKeyQliqId;
    if (!obj.extraKeys.empty()) {
        // extraKeys is an array but we support single element only
        // This is enough as now it is used only to store sender-sync key
        // If we change the code to use more elements then we should refactor this
        // to use a related qx_extra_keys table
        const qx::MediaFile::ExtraKeyDescriptor& extraKey = obj.extraKeys[0];
        extraKeyEncryptedKey = extraKey.encryptedKey;
        extraKeyPublicKeyMd5 = extraKey.publicKeyMd5;
        extraKeyQliqId = extraKey.qliqId;
    }
    q.bind(":extra_key_encrypted_key", extraKeyEncryptedKey);
    q.bind(":extra_key_public_key_md5", extraKeyPublicKeyMd5);
    q.bind(":extra_key_qliq_id", extraKeyQliqId);
}

template<>
void QxBaseDao<qx::MediaFile>::fillFromQuery(qx::MediaFile *obj, SQLite::Statement& record)
{
    obj->databaseId = record.getColumn("id").getInt();
    obj->mime = record.getColumn("mime").getText();
    obj->key = record.getColumn("key").getText();
    obj->fileName = record.getColumn("file_name").getText();
    obj->size = record.getColumn("size").getInt64();
    obj->checksum = record.getColumn("checksum").getText();
    obj->thumbnail = record.getColumn("thumbnail").getText();
    obj->url = record.getColumn("url").getText();
    obj->encryptedFilePath = record.getColumn("encrypted_file_path").getText();
    obj->decryptedFilePath = record.getColumn("decrypted_file_path").getText();
    obj->status = static_cast<qx::MediaFile::Status>(record.getColumn("status").getInt());
    obj->timestamp = static_cast<std::time_t>(record.getColumn("timestamp").getInt64());
    obj->encryptionMethod = record.getColumn("encryption_method").getText();
    obj->encryptedKey = record.getColumn("encrypted_key").getText();
    obj->publicKeyMd5 = record.getColumn("public_key_md5").getText();

    std::string extraKeyEncryptedKey = record.getColumn("extra_key_encrypted_key").getText();
    std::string extraKeyPublicKeyMd5 = record.getColumn("extra_key_public_key_md5").getText();
    std::string extraKeyQliqId = record.getColumn("extra_key_qliq_id").getText();
    if (!extraKeyEncryptedKey.empty() || !extraKeyPublicKeyMd5.empty() || !extraKeyQliqId.empty()) {
        qx::MediaFile::ExtraKeyDescriptor extraKey;
        extraKey.encryptedKey = extraKeyEncryptedKey;
        extraKey.publicKeyMd5 = extraKeyPublicKeyMd5;
        extraKey.qliqId = extraKeyQliqId;
        obj->extraKeys.push_back(extraKey);
    }
}

void qx::MediaFileDao::fillFromQuery(qx::MediaFile *obj, SQLite::Statement& record, const std::string& prefix)
{
    obj->databaseId = record.getColumn((prefix + "id").c_str()).getInt();
    obj->mime = record.getColumn((prefix + "mime").c_str()).getText();
    obj->key = record.getColumn((prefix + "key").c_str()).getText();
    obj->fileName = record.getColumn((prefix + "file_name").c_str()).getText();
    obj->size = record.getColumn((prefix + "size").c_str()).getInt64();
    obj->checksum = record.getColumn((prefix + "checksum").c_str()).getText();
    obj->thumbnail = record.getColumn((prefix + "thumbnail").c_str()).getText();
    obj->url = record.getColumn((prefix + "url").c_str()).getText();
    obj->encryptedFilePath = record.getColumn((prefix + "encrypted_file_path").c_str()).getText();
    obj->decryptedFilePath = record.getColumn((prefix + "decrypted_file_path").c_str()).getText();
    obj->status = static_cast<qx::MediaFile::Status>(record.getColumn((prefix + "status").c_str()).getInt());
    obj->timestamp = static_cast<std::time_t>(record.getColumn((prefix + "timestamp").c_str()).getInt64());
    obj->encryptionMethod = record.getColumn((prefix + "encryption_method").c_str()).getText();
    obj->encryptedKey = record.getColumn((prefix + "encrypted_key").c_str()).getText();
    obj->publicKeyMd5 = record.getColumn((prefix + "public_key_md5").c_str()).getText();

    std::string extraKeyEncryptedKey = record.getColumn((prefix + "extra_key_encrypted_key").c_str()).getText();
    std::string extraKeyPublicKeyMd5 = record.getColumn((prefix + "extra_key_public_key_md5").c_str()).getText();
    std::string extraKeyQliqId = record.getColumn((prefix + "extra_key_qliq_id").c_str()).getText();
    if (!extraKeyEncryptedKey.empty() || !extraKeyPublicKeyMd5.empty() || !extraKeyQliqId.empty()) {
        qx::MediaFile::ExtraKeyDescriptor extraKey;
        extraKey.encryptedKey = extraKeyEncryptedKey;
        extraKey.publicKeyMd5 = extraKeyPublicKeyMd5;
        extraKey.qliqId = extraKeyQliqId;
        obj->extraKeys.push_back(extraKey);
    }
}

template<>
qx::MediaFile QxBaseDao<qx::MediaFile>::fromQuery(SQLite::Statement &record)
{
    qx::MediaFile obj;
    fillFromQuery(&obj, record);
    return obj;
}

namespace qx {

bool MediaFileDao::updateUrl(int databaseId, const std::string &url, SQLite::Database &db)
{
    dao::UpdateColumns columns;
    columns[UrlColumn] = url;

    dao::WhereColumns where;
    where[IdColumn] = std::to_string(databaseId);

    return update(columns, where, db);
}

bool MediaFileDao::updateEncryptedFilePath(int databaseId, const std::string &filePath, SQLite::Database &db)
{
    dao::UpdateColumns columns;
    columns[EncryptedFilePathColumn] = filePath;

    dao::WhereColumns where;
    where[IdColumn] = std::to_string(databaseId);

    return update(columns, where, db);
}

bool MediaFileDao::updateDecryptedFilePath(int databaseId, const std::string &decryptedFilePath, SQLite::Database &db)
{
    dao::UpdateColumns columns;
    columns[DecryptedFilePathColumn] = decryptedFilePath;

    dao::WhereColumns where;
    where[IdColumn] = std::to_string(databaseId);

    return update(columns, where, db);
}

MediaFile MediaFileDao::selectOneWithId(int databaseId)
{
    return selectOneBy(IdColumn, std::to_string(databaseId));
}

} // qx
