#include "QxMediaFileUploadDao.hpp"
#include "QxMediaFileDao.hpp"

template<> const bool QxBaseDao<qx::MediaFileUpload>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::MediaFileUpload>::tableName = "qx_media_file_upload";
template<> const std::vector<std::string> QxBaseDao<qx::MediaFileUpload>::columnNames = {
    "id", "upload_uuid", "qliqstor_qliq_id", "share_type", "media_file_id",
    "raw_upload_target_json", "status", "status_message",
#ifdef QLIQ_STOR_CONTEXT
    "raw_uploaded_by_json", "uploaded_by_name", "json", "qliqstor_status",
    "extra" // field changing depending on upload type, ie. Fax number or patient id
#endif
};

template<>
QxBaseDao<qx::MediaFileUpload>::variant QxBaseDao<qx::MediaFileUpload>::primaryKey(const qx::MediaFileUpload& u)
{
    return std::to_string(u.databaseId);
}

template<>
qx::MediaFile *QxJoinedDao<qx::MediaFileUpload, qx::MediaFileDao>::joinedObject(qx::MediaFileUpload& obj)
{
    return &obj.mediaFile;
}

template<>
unsigned int QxJoinedDao<qx::MediaFileUpload, qx::MediaFileDao>::joinOtherColumn()
{
    return qx::MediaFileDao::IdColumn;
}

template<>
unsigned int QxJoinedDao<qx::MediaFileUpload, qx::MediaFileDao>::joinSelfColumn()
{
    return qx::MediaFileUploadDao::MediaFileIdColumn;
}

template<>
void QxBaseDao<qx::MediaFileUpload>::setPrimaryKey(qx::MediaFileUpload *obj, const QxBaseDao<qx::MediaFileUpload>::variant& key)
{
    obj->databaseId = std::stoi(key);
}

template<>
void QxBaseDao<qx::MediaFileUpload>::bind(SQLite::Statement& q, const qx::MediaFileUpload& obj, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", obj.databaseId);
    }
    q.bind(":upload_uuid", obj.uploadUuid);
    q.bind(":qliqstor_qliq_id", obj.qliqStorQliqId);
    q.bind(":share_type", static_cast<int>(obj.shareType));
    q.bind(":media_file_id", obj.mediaFile.databaseId);
    q.bind(":raw_upload_target_json", obj.rawUploadTargetJson);
    q.bind(":status", static_cast<int>(obj.status));
    q.bind(":status_message", obj.statusMessage);
#ifdef QLIQ_STOR_CONTEXT
    q.bind(":raw_uploaded_by_json", obj.rawUploadedByJson);
    q.bind(":uploaded_by_name", obj.uploadedByName);
    q.bind(":json", obj.json);
    q.bind(":qliqstor_status", static_cast<int>(obj.statusForClient));
    q.bind(":extra", obj.extra);
#endif
}

template<>
void QxBaseDao<qx::MediaFileUpload>::fillFromQuery(qx::MediaFileUpload *obj, SQLite::Statement& record)
{
    obj->databaseId = record.getColumn("id").getInt();
    obj->uploadUuid = record.getColumn("upload_uuid").getText();
    obj->qliqStorQliqId = record.getColumn("qliqstor_qliq_id").getText();
    obj->shareType = static_cast<qx::MediaFileUpload::ShareType>(record.getColumn("share_type").getInt());
    obj->mediaFile.databaseId = record.getColumn("media_file_id").getInt();
    obj->rawUploadTargetJson = record.getColumn("raw_upload_target_json").getText();
#ifndef QLIQ_STOR_CONTEXT
    obj->status = static_cast<qx::MediaFileUpload::OnClientStatus>(record.getColumn("status").getInt());
#else
    obj->status = static_cast<qx::MediaFileUpload::OnQliqStorStatus>(record.getColumn("status").getInt());
#endif
    obj->statusMessage = record.getColumn("status_message").getText();
#ifdef QLIQ_STOR_CONTEXT
    obj->rawUploadedByJson = record.getColumn("raw_uploaded_by_json").getText();
    obj->uploadedByName = record.getColumn("uploaded_by_name").getText();

    // The below two columns may be missing when viewing old db from customer
    using namespace qx::dao;
    obj->json = getOptionalTextColumn(record, "json");
    obj->statusForClient = static_cast<qx::MediaFileUpload::StatusForClient>(getOptionalIntColumn(record, "qliqstor_status"));
    obj->extra = getOptionalTextColumn(record, "extra");

/*
    const char *columnName = nullptr;
    try {
        columnName = "json";
        obj->json = record.getColumn(columnName).getText();
        columnName = "qliqstor_status";
        obj->qliqStorStatus = static_cast<qx::MediaFileUpload::StatusForClient>(record.getColumn(columnName).getInt());
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception, cannot get column '%s' error: %s", columnName, ex.what());
    }*/
#endif
}

template<>
qx::MediaFileUpload QxBaseDao<qx::MediaFileUpload>::fromQuery(SQLite::Statement &record)
{
    qx::MediaFileUpload obj;
    fillFromQuery(&obj, record);
    return obj;
}

#ifdef QLIQ_STOR_CONTEXT
bool qx::MediaFileUploadDao::eraseJson(int id, SQLite::Database &db)
{
    dao::UpdateColumns columns;
    columns[JsonColumn] = "";

    dao::WhereColumns where;
    where[IdColumn] = std::to_string(id);

    return update(columns, where, db);
}

bool qx::MediaFileUploadDao::updateStatus(int id, qx::MediaFileUpload::StatusForClient qliqStorStatus, qx::MediaFileUpload::OnQliqStorStatus status, const std::string &statusMessage, SQLite::Database &db)
#else
bool qx::MediaFileUploadDao::updateStatus(int id, qx::MediaFileUpload::OnClientStatus status, const std::string &statusMessage, SQLite::Database &db)
#endif
{
    dao::UpdateColumns columns;
#ifdef QLIQ_STOR_CONTEXT
    columns[QliqStorStatusColumn] = std::to_string(static_cast<int>(qliqStorStatus));
#endif
    columns[StatusColumn] = std::to_string(static_cast<int>(status));
    columns[StatusMessageColumn] = statusMessage;

    dao::WhereColumns where;
    where[IdColumn] = std::to_string(id);

    return update(columns, where, db);
}

bool qx::MediaFileUploadDao::updateStatus(const qx::MediaFileUpload& upload, SQLite::Database& db)
{
#ifdef QLIQ_STOR_CONTEXT
    return updateStatus(upload.databaseId, qx::MediaFileUpload::StatusForClient::None, upload.status, upload.statusMessage);
#else
    return updateStatus(upload.databaseId, upload.status, upload.statusMessage);
#endif
}

#ifndef QLIQ_STOR_CONTEXT

bool qx::MediaFileUploadDao::updateUploadingStatusToFailedStatus(SQLite::Database &db)
{
    dao::UpdateColumns columns;
    columns[StatusColumn] = std::to_string(MediaFileUpload::UploadToCloudFailedStatus);

    dao::WhereColumns where;
    where[StatusColumn] = std::to_string(MediaFileUpload::UploadingStatus);

    return update(columns, where, db);
}

#endif // !QLIQ_STOR_CONTEXT

#ifdef QLIQ_STOR_CONTEXT

bool qx::MediaFileUploadDao::updateDownloadingStatusToQueuedStatus(SQLite::Database &db)
{
    dao::UpdateColumns columns;
    columns[StatusColumn] = std::to_string(static_cast<int>(MediaFileUpload::OnQliqStorStatus::QueuedForDownload));

    dao::WhereColumns where;
    where[StatusColumn] = std::to_string(static_cast<int>(MediaFileUpload::OnQliqStorStatus::Downloading));

    return update(columns, where, db);
}

int qx::MediaFileUploadDao::replaceDecryptedFilePath(qx::MediaFileUpload::ShareType shareType, const std::string &oldDir, const std::string &newDir, SQLite::Database &db)
{
    int ret = 0;
    std::string sql = "UPDATE qx_media_file SET "
        " decrypted_file_path = replace(decrypted_file_path, :old_dir, :new_dir) "
        " WHERE decrypted_file_path LIKE '" + oldDir + "%' "
        " AND EXISTS (SELECT id FROM qx_media_file_upload WHERE qx_media_file_upload.media_file_id = qx_media_file.id AND qx_media_file_upload.share_type = :share_type)";

    try {
        SQLite::Statement q(db, sql);
        q.bind(":old_dir", oldDir);
        q.bind(":new_dir", newDir);
        q.bind(":share_type", static_cast<int>(shareType));
        ret = q.exec();
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}

#endif // QLIQ_SERVICE

qx::MediaFileUpload qx::MediaFileUploadDao::selectOneWithId(int id)
{
    return selectOneJoined(MediaFileUploadDao::IdColumn, std::to_string(id));
}

qx::MediaFileUpload qx::MediaFileUploadDao::selectOneWithMediaFileId(int mediaFileId)
{
    return selectOneJoined(MediaFileUploadDao::MediaFileIdColumn, std::to_string(mediaFileId));
}

std::vector<qx::MediaFileUpload> qx::MediaFileUploadDao::selectWithShareType(qx::MediaFileUpload::ShareType shareType, int skip, int limit)
{
    return selectJoined(MediaFileUploadDao::ShareTypeColumn, std::to_string(static_cast<int>(shareType)), skip, limit);
}

int qx::MediaFileUploadDao::countWithShareType(qx::MediaFileUpload::ShareType shareType)
{
    return count(MediaFileUploadDao::ShareTypeColumn, std::to_string(static_cast<int>(shareType)));
}

#ifndef QLIQ_STOR_CONTEXT

int qx::MediaFileUploadDao::countWithShareTypeAndStatus(qx::MediaFileUpload::ShareType shareType, qx::MediaFileUpload::OnClientStatus status)
{
    dao::Query query;
    query.append(MediaFileUploadDao::ShareTypeColumn, std::to_string(static_cast<int>(shareType)));
    query.and_(MediaFileUploadDao::StatusColumn, std::to_string(status));
    return count(query);
}

int qx::MediaFileUploadDao::countWithShareType(qx::MediaFileUpload::ShareType shareType, bool archived)
{
    dao::Query query;
    query.append(MediaFileUploadDao::ShareTypeColumn, std::to_string(static_cast<int>(shareType)));

    query.join(MediaFileDao::tableName,
           MediaFileDao::columnNames[MediaFileDao::IdColumn],
           MediaFileUploadDao::MediaFileIdColumn);

    dao::Query::Condition archivedCondition = archived ? dao::Query::EqualCondition :  dao::Query::NotEqualCondition;
    query.otherAnd_(MediaFileDao::tableName, MediaFileDao::columnNames[MediaFileDao::StatusColumn],
                archivedCondition, std::to_string(MediaFile::ArchivedStatus));

    return count(query);
}

int qx::MediaFileUploadDao::countSuccessfulWithShareType(qx::MediaFileUpload::ShareType shareType, bool archived)
{
    dao::Query query;
    query.append(MediaFileUploadDao::ShareTypeColumn, std::to_string(static_cast<int>(shareType)));

    MediaFileUpload::OnClientStatus status = MediaFileUpload::ThirdPartySuccessStatus;
    if (shareType == MediaFileUpload::ShareType::QliqStor) {
        status = MediaFileUpload::FinalProcessingSuccesfulStatus;
    }
    query.and_(MediaFileUploadDao::StatusColumn, std::to_string(status));

    query.join(MediaFileDao::tableName,
           MediaFileDao::columnNames[MediaFileDao::IdColumn],
           MediaFileUploadDao::MediaFileIdColumn);

    dao::Query::Condition archivedCondition = archived ?  dao::Query::EqualCondition :  dao::Query::NotEqualCondition;
    query.otherAnd_(MediaFileDao::tableName, MediaFileDao::columnNames[MediaFileDao::StatusColumn],
                archivedCondition, std::to_string(MediaFile::ArchivedStatus));

    return count(query);
}

#endif
