#include "QxSipLogRecordDao.hpp"
#include <cctype>
#include <cstring>
#include "qxlib/log/QxLog.hpp"
#include "qxlib/util/StringUtils.hpp"
#ifdef DB_LOG_USE_ZSTD
#include "qxlib/util/QxZstd.hpp"
#endif
#ifdef QXL_HAS_QT
#include <QDebug>
#endif

template<> const bool QxBaseDao<qx::SipLogRecord>::autogeneratedPrimaryKey = true;
template<> const std::string QxBaseDao<qx::SipLogRecord>::tableName = "sip_log";
template<> const std::vector<std::string> QxBaseDao<qx::SipLogRecord>::columnNames = {
    "id", "session", "sequence_id", "timestamp", "direction",
    "method", "from_", "to_", "status_code", "duration", "call_id", "cseq",
    "request", "response", "plaintext_request_body", "decryption_status"
};

template<>
QxBaseDao<qx::SipLogRecord>::variant QxBaseDao<qx::SipLogRecord>::primaryKey(const qx::SipLogRecord& u)
{
    return std::to_string(u.id);
}

template<>
void QxBaseDao<qx::SipLogRecord>::setPrimaryKey(qx::SipLogRecord *obj, const QxBaseDao<qx::SipLogRecord>::variant& key)
{
    obj->id = std::stoi(key);
}

template<>
void QxBaseDao<qx::SipLogRecord>::bind(SQLite::Statement& q, const qx::SipLogRecord& obj, bool skipPrimaryKey)
{
    if (!skipPrimaryKey) {
        q.bind(":id", obj.id);
    }
    q.bind(":session", static_cast<int>(obj.session));
    q.bind(":sequence_id", obj.sequenceId);
    q.bind(":timestamp", static_cast<int>(obj.time));
    q.bind(":direction", static_cast<int>(obj.direction));
    q.bind(":method", obj.method);
    q.bind(":from_", obj.from);
    q.bind(":to_", obj.to);
    q.bind(":status_code", obj.statusCode);
    q.bind(":duration", obj.duration);
    q.bind(":call_id", obj.callId);
    q.bind(":cseq", obj.cseq);
    q.bind(":request", obj.request);
    q.bind(":response", obj.response);
    q.bind(":plaintext_request_body", obj.plainTextRequestBody);
    q.bind(":decryption_status", static_cast<int>(obj.decryptionStatus));
}

template<>
void QxBaseDao<qx::SipLogRecord>::fillFromQuery(qx::SipLogRecord *obj, SQLite::Statement& record)
{
    obj->id = record.getColumn("id").getInt();
    obj->session = record.getColumn("session").getInt();
    obj->sequenceId = record.getColumn("sequence_id").getInt();
    obj->time = record.getColumn("timestamp").getInt();
    obj->direction = static_cast<qx::SipLogRecord::Direction>(record.getColumn("direction").getInt());
    obj->method = record.getColumn("method").getText();
    obj->from = record.getColumn("from_").getText();
    obj->to = record.getColumn("to_").getText();
    obj->statusCode = record.getColumn("status_code").getInt();
    obj->duration = record.getColumn("duration").getInt();
    obj->callId = record.getColumn("call_id").getText();
    obj->cseq = record.getColumn("cseq").getText();
    obj->request = record.getColumn("request").getText();
    obj->response = record.getColumn("response").getText();
    obj->plainTextRequestBody = record.getColumn("plaintext_request_body").getText();
    obj->decryptionStatus = static_cast<qx::SipLogRecord::DecryptionStatus>(record.getColumn("decryption_status").getInt());
}

template<>
qx::SipLogRecord QxBaseDao<qx::SipLogRecord>::fromQuery(SQLite::Statement &record)
{
    qx::SipLogRecord obj;
    fillFromQuery(&obj, record);
    return obj;
}

namespace {

std::string headerValue(const std::string& name, const std::string& str, std::size_t maxPos = std::string::npos)
{
    // According to RFC header should end with \r\n but webserver can sometimes send \n
    // so we need to handle both line endings
    std::string separatorAndName = "\n" + name + ":";
    if (maxPos == std::string::npos) {
        maxPos = str.size();
    }
    std::size_t pos = str.find(separatorAndName);
    if (pos < maxPos) {
        pos += separatorAndName.size();
        while (std::isspace(str[pos])) {
            ++pos;
        }
        std::size_t newLinePos = str.find('\n', pos);
        if (newLinePos < maxPos) {
            if (str[newLinePos-1] == '\r') {
                newLinePos--;
            }
            return str.substr(pos, newLinePos - pos);
        }
    }
    return "";
}

std::string stripSip(const std::string& text)
{
    std::string sipUri = text;
    if (sipUri[0] == '<') {
        sipUri.erase(sipUri.begin());
        // There can be more data after the closing >;tag=...
        std::string::size_type pos = sipUri.find('>');
        if (pos != std::string::npos) {
            sipUri.erase(sipUri.begin() + pos, sipUri.end());
        }
    }
    if (StringUtils::startsWith(sipUri, "sip:"))
        sipUri.erase(0, 4);

    return sipUri;
}

std::string qliqIdFromSipUri(std::string sipUri)
{
    std::string::size_type pos = sipUri.find('@');
    if (pos != std::string::npos) {
        sipUri.erase(sipUri.begin() + pos, sipUri.end());
    }
    return sipUri;
}

}

bool qx::SipLogRecordDao::updateResponse(const qx::SipLogRecord &record, SQLite::Database& db)
{
    bool ret = false;
    std::string sql = "UPDATE " + tableName + " SET duration = (:now_time - timestamp), status_code = :status_code, response = :response "
        " WHERE session = :session AND call_id = :call_id AND cseq = :cseq";
    try {
        SQLite::Statement q(db, sql);
        q.bind(":session", static_cast<int>(record.session));
        q.bind(":call_id", record.callId);
        q.bind(":cseq", record.cseq);
        q.bind(":status_code", record.statusCode);
        //q.bind(":duration", record.duration);
        q.bind(":now_time", static_cast<int>(std::time(nullptr)));
        q.bind(":response", record.response);
        ret = q.exec();
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}

bool qx::SipLogRecordDao::parse(qx::SipLogRecord *record, const char *msg, std::size_t msgLen, qx::SipLogRecord::Direction direction, bool isRequest, const char *plainText)
{
    if (!msg || msgLen == 0)
        return false;

    std::string message(msg, msgLen);

    std::size_t headersLen = message.find("\r\n\r\n");
    if (headersLen == std::string::npos) {
        headersLen = message.size();
    }

    record->session = qxlog::Logger::instance().sessionId();
    record->cseq = headerValue("CSeq", message, headersLen);
    record->callId = headerValue("Call-ID", message, headersLen);

    std::string contentType = headerValue("Content-Type", message, headersLen);
    // It may include extra fields like charset:
    // text/html; charset=utf-8
    contentType = StringUtils::left(contentType, StringUtils::indexOf(contentType, ';'));
    // Normalize, protect against strange SIP clients (ie. web script)
    contentType = StringUtils::toLowerCase(StringUtils::trim(contentType));

    bool isEncrypted = (contentType == "application/octet-stream");

    if (isRequest) {
        record->sequenceId = qxlog::Logger::instance().nextSequenceId();
        record->time = std::time(nullptr);
        record->direction = direction;

        record->method = message.substr(0, message.find(' '));

        record->from = headerValue("From", message, headersLen);
        record->from = qliqIdFromSipUri(stripSip(record->from));

        record->to = headerValue("To", message, headersLen);
        record->to = qliqIdFromSipUri(stripSip(record->to));

#ifndef DB_LOG_USE_ZSTD
        record->request = std::move(message);
#else
        Zstd::compress(message, &record->request);
#endif

        if (isEncrypted) {
            if (plainText) {
                record->decryptionStatus = SipLogRecord::DecryptedDecryptionStatus;
                record->plainTextRequestBody = plainText;
#ifndef DB_LOG_USE_ZSTD
                record->plainTextRequestBody = plainText;
#else
                Zstd::compress(plainText, &record->plainTextRequestBody);
#endif
            } else {
                record->decryptionStatus = SipLogRecord::PendingDecryptionStatus;
            }
        } else {
#if defined(QXL_HAS_QT) && !defined(QT_NO_DEBUG)
            if (record->method == "MESSAGE" && contentType != "application/octet-stream" && contentType != "text/plain" && contentType != "text/plain; charset=utf-8") {
                qDebug() << "Unexpected Content-Type in SIP message: " << contentType.c_str();
            }
#endif
             record->decryptionStatus = SipLogRecord::PlainTextDecryptionStatus;
        }
    } else {
        {
            // Extract status code from: "SIP/2.0 200 OK", where "OK" is optional
            auto startPos = message.find(' ');
            if (startPos < std::string::npos) {
                ++startPos;
                auto endPos = message.find(' ', startPos);
                if (endPos == std::string::npos) {
                    endPos = message.find("\r\n", startPos);
                }
                if (endPos < std::string::npos) {
                    const auto& substr = message.substr(startPos, endPos - startPos);
                    record->statusCode = std::stoi(substr);
                }
            }
        }
        record->duration = static_cast<int>(std::difftime(std::time(nullptr), record->time));
#ifndef DB_LOG_USE_ZSTD
        record->response = std::move(message);
#else
        Zstd::compress(message, &record->response);
#endif
    }

    return true;
}

bool qx::SipLogRecordDao::save(const qx::SipLogRecord& record, bool isRequest, SQLite::Database &db)
{
    if (isRequest) {
        return SipLogRecordDao::insert(record, db);
    } else {
        return SipLogRecordDao::updateResponse(record, db);
    }
}

int qx::SipLogRecordDao::parseAndSave(const char *msg, std::size_t msgLen, qx::SipLogRecord::Direction direction, bool isRequest, const char *plainText, SQLite::Database& db)
{
    if (!msg || msgLen == 0)
        return 0;

    std::string message(msg, msgLen);

    std::size_t headersLen = message.find("\r\n\r\n");
    if (headersLen == std::string::npos) {
        headersLen = message.size();
    }

    qx::SipLogRecord record;
    record.session = qxlog::Logger::instance().sessionId();
    record.cseq = headerValue("CSeq", message, headersLen);
    record.callId = headerValue("Call-ID", message, headersLen);

    std::string contentType = headerValue("Content-Type", message, headersLen);
    // It may include extra fields like charset:
    // text/html; charset=utf-8
    contentType = StringUtils::left(contentType, StringUtils::indexOf(contentType, ';'));
    // Normalize, protect against stange SIP clients (ie. web script)
    contentType = StringUtils::toLowerCase(StringUtils::trim(contentType));

    bool isEncrypted = (contentType == "application/octet-stream");

    if (isRequest) {
        record.sequenceId = qxlog::Logger::instance().nextSequenceId();
        record.time = std::time(nullptr);
        record.direction = direction;

        record.method = message.substr(0, message.find(' '));

        record.from = headerValue("From", message, headersLen);
        record.from = qliqIdFromSipUri(stripSip(record.from));

        record.to = headerValue("To", message, headersLen);
        record.to = qliqIdFromSipUri(stripSip(record.to));

#ifndef DB_LOG_USE_ZSTD
        record.request = std::move(message);
#else
        Zstd::compress(message, &record.request);
#endif

        if (isEncrypted) {
            if (plainText) {
                record.decryptionStatus = SipLogRecord::DecryptedDecryptionStatus;
                record.plainTextRequestBody = plainText;
#ifndef DB_LOG_USE_ZSTD
                record.plainTextRequestBody = plainText;
#else
                Zstd::compress(plainText, &record.plainTextRequestBody);
#endif
            } else {
                record.decryptionStatus = SipLogRecord::PendingDecryptionStatus;
            }
        } else {
#if defined(QXL_HAS_QT) && !defined(QT_NO_DEBUG)
            if (record.method == "MESSAGE" && contentType != "application/octet-stream" && contentType != "text/plain" && contentType != "text/plain; charset=utf-8") {
                qDebug() << "Unexpected Content-Type in SIP message: " << contentType.c_str();
            }
#endif
             record.decryptionStatus = SipLogRecord::PlainTextDecryptionStatus;
        }
        SipLogRecordDao::insert(&record, db);
    } else {
        {
            // Extract status code from: "SIP/2.0 200 OK", where "OK" is optional
            auto startPos = message.find(' ');
            if (startPos < std::string::npos) {
                ++startPos;
                auto endPos = message.find(' ', startPos);
                if (endPos == std::string::npos) {
                    endPos = message.find("\r\n", startPos);
                }
                if (endPos < std::string::npos) {
                    const auto& substr = message.substr(startPos, endPos - startPos);
                    record.statusCode = std::stoi(substr);
                }
            }
        }
        record.duration = static_cast<int>(std::difftime(std::time(nullptr), record.time));
#ifndef DB_LOG_USE_ZSTD
        record.response = std::move(message);
#else
        Zstd::compress(message, &record.response);
#endif

        SipLogRecordDao::updateResponse(record, db);
    }

    return 0;
}

bool qx::SipLogRecordDao::decryptMessagesWithNewKey(const char *privKey, const char *xhash, const char *qliqId, DecryptionCallback decryptionCallback, SQLite::Database& db)
{
    bool ret = false;
    std::string sql = "SELECT id, request FROM " + tableName + " WHERE to_ = :to AND decryption_status = :decryption_status";
    try {
        SQLite::Statement q(db, sql);
        q.bind(":to", qliqId);
        q.bind(":decryption_status", SipLogRecord::PendingDecryptionStatus);
        while (q.executeStep()) {
            int id = q.getColumn(0).getInt();
#ifndef DB_LOG_USE_ZSTD
            const char *request = q.getColumn(1).getText();
#else
            int requestLen;
            const char *request = q.getColumn(1).getText(&requestLen);
            std::unique_ptr<char[]> decompressedRequest;
            auto size = Zstd::decompress(request, requestLen, &decompressedRequest);
            if (size > 0) {
                request = decompressedRequest.get();
            } else {
                continue;
            }
#endif
            const char *body = std::strstr(request, "\r\n\r\n");
            if (body) {
                body += 4;

                std::string decrypted;
                bool ok = decryptionCallback(privKey, body, &decrypted);
                std::string sql2;
                try {
                    if (ok) {
                        sql2 = "UPDATE " + tableName + " SET plaintext_request_body = :body, decryption_status = :decryption_status WHERE id = :id";
                        SQLite::Statement q2(db, sql2);
                        q2.bind(":id", id);
#ifndef DB_LOG_USE_ZSTD
                        q2.bind(":body", decrypted);
#else
                        std::string compressedDecrypted;
                        Zstd::compress(decrypted, &compressedDecrypted);
                        q2.bind(":body", compressedDecrypted);
#endif
                        q2.bind(":decryption_status", SipLogRecord::DecryptedDecryptionStatus);
                        ok = q2.exec() == 1;
                    } else {
                        sql2 = "UPDATE " + tableName + " SET decryption_status = :decryption_status WHERE id = :id";
                        SQLite::Statement q2(db, sql2);
                        q2.bind(":id", id);
                        q2.bind(":decryption_status", SipLogRecord::PermanentErrorDecryptionStatus);
                        ok = q2.exec() == 1;
                    }
                } catch (const SQLite::Exception& ex) {
                    QXLOG_ERROR("DB exception for query: '%s' error: %s", sql2.c_str(), ex.what());
                }
            }
        }
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}

bool qx::SipLogRecordDao::updateDebugExtra(const std::string &callId, const std::string &cseq, const std::string &debugExtra, SQLite::Database& db)
{
    bool ret = false;
    std::string sql = "UPDATE " + tableName + " SET debug_extra = :debug_extra "
        " WHERE session = :session AND call_id = :call_id AND cseq = :cseq";
    try {
        SQLite::Statement q(db, sql);
        q.bind(":session", static_cast<int>(qxlog::Logger::instance().sessionId()));
        q.bind(":call_id", callId);
        q.bind(":cseq", cseq);
        q.bind(":debug_extra", debugExtra);
        ret = q.exec();
    } catch (const SQLite::Exception& ex) {
        QXLOG_ERROR("DB exception for query: '%s' error: %s", sql.c_str(), ex.what());
    }
    return ret;
}
